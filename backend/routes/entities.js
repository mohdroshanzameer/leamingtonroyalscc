// backend/routes/entities.js

const express = require("express");
const { pool } = require("../db/pool");
const { authenticateToken } = require("../middleware/auth");
const { quoteIdent, resolveTable, resolveOrderBy } = require("../utils/sqlSafe");

// IMPORTANT: we need DB_COLUMNS for safe inserts
const { DB_COLUMNS } = require("../db/pool");

const router = express.Router();

/**
 * GET /api/entities/:entityName?sort=...&limit=...&offset=...
 */
router.get("/:entityName", authenticateToken, async (req, res) => {
  try {
    const entity = req.params.entityName;
    const table = resolveTable(entity);
    if (!table) return res.status(400).json({ error: `Unknown entity: ${entity}` });

    const limit = Math.min(parseInt(req.query.limit || "100", 10) || 100, 1000);
    const offset = Math.max(parseInt(req.query.offset || "0", 10) || 0, 0);
    const order = resolveOrderBy(table, req.query.sort);

    const orderSql = order
      ? `ORDER BY ${quoteIdent(order.col)} ${order.desc ? "DESC" : "ASC"}`
      : "";

    const sql = `SELECT * FROM ${quoteIdent(table)} ${orderSql} LIMIT $1 OFFSET $2`;
    const rows = (await pool.query(sql, [limit, offset])).rows;

    res.json(rows);
  } catch (err) {
    console.error("Entities GET error:", err);
    res.status(500).json({ error: err.message });
  }
});

/**
 * POST /api/entities/:entityName/filter
 * Body: { options: { sort, limit, offset } }
 */
router.post("/:entityName/filter", authenticateToken, async (req, res) => {
  try {
    const entity = req.params.entityName;
    const table = resolveTable(entity);
    if (!table) return res.status(400).json({ error: `Unknown entity: ${entity}` });

    const opts = req.body?.options || {};
    const limit = Math.min(parseInt(opts.limit || "100", 10) || 100, 1000);
    const offset = Math.max(parseInt(opts.offset || "0", 10) || 0, 0);
    const order = resolveOrderBy(table, opts.sort);

    const orderSql = order
      ? `ORDER BY ${quoteIdent(order.col)} ${order.desc ? "DESC" : "ASC"}`
      : "";

    const sql = `SELECT * FROM ${quoteIdent(table)} ${orderSql} LIMIT $1 OFFSET $2`;
    const rows = (await pool.query(sql, [limit, offset])).rows;

    res.json(rows);
  } catch (err) {
    console.error("Entities FILTER error:", err);
    res.status(500).json({ error: err.message });
  }
});

/**
 * POST /api/entities/:entityName
 * Create row safely.
 * Accepts either:
 *  - body = { colA: ..., colB: ... }
 *  - body = { data: { colA: ..., colB: ... } }
 */
router.post("/:entityName", authenticateToken, async (req, res) => {
  try {
    const entity = req.params.entityName;
    const table = resolveTable(entity);
    if (!table) return res.status(400).json({ error: `Unknown entity: ${entity}` });

    const payload = req.body?.data && typeof req.body.data === "object" ? req.body.data : req.body;

    if (!payload || typeof payload !== "object" || Array.isArray(payload)) {
      return res.status(400).json({ error: "Invalid request body. Expected an object." });
    }

    const tableCols = DB_COLUMNS.get(table);
    if (!tableCols) {
      return res.status(500).json({ error: `Column metadata not loaded for table: ${table}` });
    }

    // Only allow columns that exist in the DB table
    const allowedKeys = Object.keys(payload).filter((k) => tableCols.has(k));

    // Optional: prevent overwriting typical autogenerated/audit fields
    const blocked = new Set(["id", "created_date", "updated_date"]);
    const insertKeys = allowedKeys.filter((k) => !blocked.has(k));

    if (insertKeys.length === 0) {
      return res.status(400).json({
        error: `No valid insertable fields for ${entity}.`,
        hint: `Allowed columns: ${[...tableCols].join(", ")}`,
      });
    }

    const values = insertKeys.map((k) => payload[k]);
    const colsSql = insertKeys.map((c) => quoteIdent(c)).join(", ");
    const paramsSql = insertKeys.map((_, i) => `$${i + 1}`).join(", ");

    const sql = `
      INSERT INTO ${quoteIdent(table)} (${colsSql})
      VALUES (${paramsSql})
      RETURNING *
    `;

    const result = await pool.query(sql, values);
    res.status(201).json(result.rows[0]);
  } catch (err) {
    console.error("Entities CREATE error:", err);
    res.status(500).json({ error: err.message });
  }
});

module.exports = router;
